{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"flask.api.app/","title":"App","text":""},{"location":"flask.api.app/#src.flask_api.app.app.handle_error","title":"<code>handle_error(exception)</code>","text":"<p>Handles an exception and returns an appropriate response based on the type of exception.</p> <p>Parameters:</p> Name Type Description Default <code>exception</code> <code>Exception</code> <p>The exception that was raised.</p> required <p>Returns:</p> Name Type Description <code>Response</code> <p>The response object containing the appropriate status code and error message.</p> Source code in <code>src/flask_api/app/app.py</code> <pre><code>def handle_error(exception: Exception):\n    \"\"\"\n    Handles an exception and returns an appropriate response based on the type of exception.\n\n    Parameters:\n        exception (Exception): The exception that was raised.\n\n    Returns:\n        Response: The response object containing the appropriate status code and error message.\n\n    \"\"\"\n    if isinstance(exception, BaseErrorResponse):\n        return Response(exception.status_code, exception.errors)\n\n    log_msg = f\"{type(exception).__name__} - {exception}\"\n    current_app.logger.error(log_msg)\n\n    if current_app.debug:\n        current_app.logger.error(\n            log_msg + \"\\n\" + traceback.format_exc()\n        )\n\n    return Response(\n        ServerError.status_code,\n        data={\"error\": ServerError.default_err_msg},\n    )\n</code></pre>"},{"location":"flask.api.app/#src.flask_api.app.app.create_app","title":"<code>create_app()</code>","text":"<p>Creates a Flask application instance.</p> <p>This function initializes a Flask application with the  specified configuration. It registers the <code>TransactionBlueprint</code> blueprint  and sets up the necessary routes. It also sets up a catch-all route to  handle invalid paths and an error handler for unhandled exceptions.</p> <p>Returns:</p> Name Type Description <code>Flask</code> <code>Flask</code> <p>The Flask application instance.</p> Source code in <code>src/flask_api/app/app.py</code> <pre><code>def create_app() -&gt; Flask:\n    \"\"\"\n    Creates a Flask application instance.\n\n    This function initializes a Flask application with the \n    specified configuration. It registers the `TransactionBlueprint` blueprint \n    and sets up the necessary routes. It also sets up a catch-all route to \n    handle invalid paths and an error handler for unhandled exceptions.\n\n    Returns:\n        Flask: The Flask application instance.\n\n    \"\"\"\n    app = Flask(__name__)\n    app.config.from_object(APIConfig())\n    api = Api(app)\n    api.register_blueprint(TransactionBlueprint)\n\n    @app.route(\"/\")\n    def index():\n        return Response(200, data=\"Server is up\")\n\n    @app.route('/', defaults={'path': ''})\n    @app.route('/&lt;path:path&gt;')\n    def _catch_all(*args, **kwargs):\n        try:\n            raise BadRequest(\"Invalid path\", debug=kwargs)\n        except Exception as e:\n            current_app.logger.error(\n                \"Catch all error - Unhandled exception \" \n                + f\"{type(e).__name__}: {e}\",\n                exc_info=True)\n            return Response(\n                ServerError.status_code,\n                data={\"error\": ServerError.default_err_msg})\n\n    app.errorhandler(Exception)(handle_error)\n\n    # setup()\n    # app.app_context().push()  # i.e. before_first_request\n    return app\n</code></pre>"},{"location":"flask.api.responses/","title":"Responses","text":""},{"location":"flask.api.responses/#responses","title":"Responses","text":""},{"location":"flask.api.responses/#src.flask_api.app.api.exceptions.Response","title":"<code>Response</code>","text":"<p>Construct a Flask response with the given status code and data.</p> <p>This class is used as a simple way to return a JSON response from an API endpoint. It is a factory function that returns a Flask response with the given status code and data.</p> <p>Parameters:</p> Name Type Description Default <code>status_code</code> <code>int</code> <p>The status code for the response</p> required <code>data</code> <code>Any</code> <p>The data to include in the response</p> required <p>Returns:</p> Name Type Description <code>Response</code> <p>A Flask response with the given status code and data</p> Source code in <code>src/flask_api/app/api/exceptions.py</code> <pre><code>class Response:\n    \"\"\"\n    Construct a Flask response with the given status code and data.\n\n    This class is used as a simple way to return a JSON response from\n    an API endpoint. It is a factory function that returns a Flask\n    response with the given status code and data.\n\n    Args:\n        status_code (int): The status code for the response\n        data (Any): The data to include in the response\n\n    Returns:\n        Response: A Flask response with the given status code and data\n    \"\"\"\n    def __new__(self, status_code: int, data: Any):\n        \"\"\"\n        Construct a Flask response with the given status code and data.\n\n        Args:\n            status_code (int): The status code for the response\n            data (Any): The data to include in the response\n\n        Returns:\n            Response: A Flask response with the given status code and data\n        \"\"\"\n        return make_response(jsonify(data), status_code)\n</code></pre>"},{"location":"flask.api.responses/#src.flask_api.app.api.exceptions.Response.__new__","title":"<code>__new__(status_code, data)</code>","text":"<p>Construct a Flask response with the given status code and data.</p> <p>Parameters:</p> Name Type Description Default <code>status_code</code> <code>int</code> <p>The status code for the response</p> required <code>data</code> <code>Any</code> <p>The data to include in the response</p> required <p>Returns:</p> Name Type Description <code>Response</code> <p>A Flask response with the given status code and data</p> Source code in <code>src/flask_api/app/api/exceptions.py</code> <pre><code>def __new__(self, status_code: int, data: Any):\n    \"\"\"\n    Construct a Flask response with the given status code and data.\n\n    Args:\n        status_code (int): The status code for the response\n        data (Any): The data to include in the response\n\n    Returns:\n        Response: A Flask response with the given status code and data\n    \"\"\"\n    return make_response(jsonify(data), status_code)\n</code></pre>"},{"location":"flask.api.responses/#src.flask_api.app.api.exceptions.BaseErrorResponse","title":"<code>BaseErrorResponse</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for custom error responses</p> <p>This class is used as a base class for custom error responses. It provides a simple way to return a JSON response with a status code and some data.</p> <p>Attributes:</p> Name Type Description <code>status_code</code> <code>int</code> <p>The status code for the response</p> <code>default_err_msg</code> <code>str</code> <p>The default error message</p> <code>public</code> <code>dict[str, str] | str | None</code> <p>The public error message</p> <code>debug</code> <code>dict[str, str] | str | None</code> <p>The debug message</p> Source code in <code>src/flask_api/app/api/exceptions.py</code> <pre><code>class BaseErrorResponse(Exception):\n    \"\"\"Base class for custom error responses\n\n    This class is used as a base class for custom error responses. It\n    provides a simple way to return a JSON response with a status code\n    and some data.\n\n    Attributes:\n        status_code (int): The status code for the response\n        default_err_msg (str): The default error message\n        public (dict[str, str] | str | None): The public error message\n        debug (dict[str, str] | str | None): The debug message\n    \"\"\"\n    status_code: int\n    default_err_msg: str\n    public: Optional[Union[Dict[str, str], str]] = None\n    debug: Optional[Union[Dict[str, str], str]] = None\n\n    def __init__(self, public, debug) -&gt; None:\n        \"\"\"Initialize the class\n\n        Args:\n            public (Optional[Union[Dict[str, str], str]]): The public error message\n            debug (Optional[Union[Dict[str, str], str]]): The debug message\n        \"\"\"\n        self.public = public\n        self.debug = debug\n        self._log()\n\n\n    @property\n    def errors(self) -&gt; dict:\n        \"\"\"Return the errors\n\n        Returns:\n            dict: The errors\n        \"\"\"\n        err_msg = self.public or self.default_err_msg\n        return {\"error\": err_msg}\n\n\n    def _log(self):\n        \"\"\"Log the debug message\n        \"\"\"\n        if self.debug is None:\n            return\n\n        if isinstance(self.debug, list):\n            for msg in self.debug:\n                current_app.logger.debug(f\"{type(self).__name__} = {msg}\")\n        else:\n            current_app.logger.debug(f\"{type(self).__name__} = {self.debug}\")\n</code></pre>"},{"location":"flask.api.responses/#src.flask_api.app.api.exceptions.BaseErrorResponse.errors","title":"<code>errors: dict</code>  <code>property</code>","text":"<p>Return the errors</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The errors</p>"},{"location":"flask.api.responses/#src.flask_api.app.api.exceptions.BaseErrorResponse.__init__","title":"<code>__init__(public, debug)</code>","text":"<p>Initialize the class</p> <p>Parameters:</p> Name Type Description Default <code>public</code> <code>Optional[Union[Dict[str, str], str]]</code> <p>The public error message</p> required <code>debug</code> <code>Optional[Union[Dict[str, str], str]]</code> <p>The debug message</p> required Source code in <code>src/flask_api/app/api/exceptions.py</code> <pre><code>def __init__(self, public, debug) -&gt; None:\n    \"\"\"Initialize the class\n\n    Args:\n        public (Optional[Union[Dict[str, str], str]]): The public error message\n        debug (Optional[Union[Dict[str, str], str]]): The debug message\n    \"\"\"\n    self.public = public\n    self.debug = debug\n    self._log()\n</code></pre>"},{"location":"flask.api.responses/#src.flask_api.app.api.exceptions.BadRequest","title":"<code>BadRequest</code>","text":"<p>               Bases: <code>BaseErrorResponse</code></p> Source code in <code>src/flask_api/app/api/exceptions.py</code> <pre><code>class BadRequest(BaseErrorResponse):\n    status_code = 400\n    default_message = \"Bad Request\"\n\n    def __init__(\n            self,\n            message: Optional[str] = None,\n            debug: Optional[Union[Dict[str, str], str]] = None\n    ) -&gt; None:\n        \"\"\"Initialize the class\n\n        Args:\n            message (Optional[str]): The public error message\n            debug (Optional[Union[Dict[str], str]]): The debug message\n        \"\"\"\n        super().__init__(message or self.default_message, debug)\n</code></pre>"},{"location":"flask.api.responses/#src.flask_api.app.api.exceptions.BadRequest.__init__","title":"<code>__init__(message=None, debug=None)</code>","text":"<p>Initialize the class</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>Optional[str]</code> <p>The public error message</p> <code>None</code> <code>debug</code> <code>Optional[Union[Dict[str], str]]</code> <p>The debug message</p> <code>None</code> Source code in <code>src/flask_api/app/api/exceptions.py</code> <pre><code>def __init__(\n        self,\n        message: Optional[str] = None,\n        debug: Optional[Union[Dict[str, str], str]] = None\n) -&gt; None:\n    \"\"\"Initialize the class\n\n    Args:\n        message (Optional[str]): The public error message\n        debug (Optional[Union[Dict[str], str]]): The debug message\n    \"\"\"\n    super().__init__(message or self.default_message, debug)\n</code></pre>"},{"location":"flask.api.transactions/","title":"Endpoints","text":""},{"location":"flask.api.transactions/#transactions-endpoint","title":"Transactions Endpoint","text":""},{"location":"flask.api.transactions/#src.flask_api.app.api.transactions.Transaction","title":"<code>Transaction</code>","text":"<p>               Bases: <code>MethodView</code></p> <p>Endpoint for processing transactions</p> Source code in <code>src/flask_api/app/api/transactions.py</code> <pre><code>@blp.route(\"/transactions\")\nclass Transaction(MethodView):\n    \"\"\"Endpoint for processing transactions\"\"\"\n\n    # Validate and send the data to Kafka or a valid bucket\n    def post(self)-&gt; Response:\n        \"\"\"\n        Process a transaction by validating the data and sending it to the \n        appropriate destination.\n\n        Returns:\n            str: The original transaction data JSON response.\n\n        Raises:\n            ValidationError: If the transaction data fails validation.\n        \"\"\"\n        resp = request.get_json()\n\n        # Generates a unique object name based on the transaction data. \n        obj_name = generate_object_name(resp)\n        try:\n            # Validate the transaction data using the `TransactionStream` model. \n            item = TransactionData.model_validate_json(resp)\n\n            # Checks if the transaction is flagged as fraud. \n            # If flagged as fraud, transaction data is stored in the `bucket_fraud` MinIO bucket. \n            if item.is_fraud:\n                print(\"is_fraud\")\n                object_store.put_json(\n                    minio_client, FXConfig().bucket_fraud, obj_name, item.model_dump()\n                )\n            else:\n                print(\"not_fraud\")\n                try:\n                # Transaction data is sent to the Kafka topic specified in the configuration.\n                    producer.send_message(\n                        KafkaConfig().topic,\n                        payload=item.model_dump(),\n                        poll_timeout_secs=0.1,\n                    )\n                except Exception as e:\n                    print(e)\n        except ValidationError as exc:\n            print(\"validation failed\")\n            # If the validation fails, a `ValidationError` exception is raised. \n            # JSON response modified to include the validation errors. \n            request_json = json.dumps({**json.loads(resp), \"errors\": exc.errors()})\n\n            # The modified response is then stored in the `bucket_valid` MinIO bucket.\n            object_store.put_json(\n                minio_client, FXConfig().bucket_valid, obj_name, json.loads(request_json)\n            )\n        finally:\n            return Response(200, data=resp)\n</code></pre>"},{"location":"flask.api.transactions/#src.flask_api.app.api.transactions.Transaction.post","title":"<code>post()</code>","text":"<p>Process a transaction by validating the data and sending it to the  appropriate destination.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>Response</code> <p>The original transaction data JSON response.</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If the transaction data fails validation.</p> Source code in <code>src/flask_api/app/api/transactions.py</code> <pre><code>def post(self)-&gt; Response:\n    \"\"\"\n    Process a transaction by validating the data and sending it to the \n    appropriate destination.\n\n    Returns:\n        str: The original transaction data JSON response.\n\n    Raises:\n        ValidationError: If the transaction data fails validation.\n    \"\"\"\n    resp = request.get_json()\n\n    # Generates a unique object name based on the transaction data. \n    obj_name = generate_object_name(resp)\n    try:\n        # Validate the transaction data using the `TransactionStream` model. \n        item = TransactionData.model_validate_json(resp)\n\n        # Checks if the transaction is flagged as fraud. \n        # If flagged as fraud, transaction data is stored in the `bucket_fraud` MinIO bucket. \n        if item.is_fraud:\n            print(\"is_fraud\")\n            object_store.put_json(\n                minio_client, FXConfig().bucket_fraud, obj_name, item.model_dump()\n            )\n        else:\n            print(\"not_fraud\")\n            try:\n            # Transaction data is sent to the Kafka topic specified in the configuration.\n                producer.send_message(\n                    KafkaConfig().topic,\n                    payload=item.model_dump(),\n                    poll_timeout_secs=0.1,\n                )\n            except Exception as e:\n                print(e)\n    except ValidationError as exc:\n        print(\"validation failed\")\n        # If the validation fails, a `ValidationError` exception is raised. \n        # JSON response modified to include the validation errors. \n        request_json = json.dumps({**json.loads(resp), \"errors\": exc.errors()})\n\n        # The modified response is then stored in the `bucket_valid` MinIO bucket.\n        object_store.put_json(\n            minio_client, FXConfig().bucket_valid, obj_name, json.loads(request_json)\n        )\n    finally:\n        return Response(200, data=resp)\n</code></pre>"},{"location":"flask.api.transactions/#src.flask_api.app.api.transactions.generate_object_name","title":"<code>generate_object_name(request_json)</code>","text":"<p>Generates a file name based on the contents of the PUT request</p> <p>The file name is in the format of  <code>/&lt;year&gt;&lt;month&gt;&lt;day&gt;/&lt;hour&gt;00/&lt;transaction_number&gt;.txt</code> where  <code>&lt;year&gt;&lt;month&gt;&lt;day&gt;</code> is the current date in UTC time, <code>&lt;hour&gt;</code> is the current hour in UTC time, and <code>&lt;transaction_number&gt;</code> is the transaction number from the request.</p> <p>Parameters:</p> Name Type Description Default <code>request_json</code> <code>str</code> <p>PUT request in json format</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>name of file object to be stored in MinIO</p> Source code in <code>src/flask_api/app/api/transactions.py</code> <pre><code>def generate_object_name(request_json: str) -&gt; str:\n    \"\"\"\n    Generates a file name based on the contents of the PUT request\n\n    The file name is in the format of \n    `/&lt;year&gt;&lt;month&gt;&lt;day&gt;/&lt;hour&gt;00/&lt;transaction_number&gt;.txt` where \n    `&lt;year&gt;&lt;month&gt;&lt;day&gt;` is the current date in UTC time,\n    `&lt;hour&gt;` is the current hour in UTC time, and\n    `&lt;transaction_number&gt;` is the transaction number from the request.\n\n    Args:\n        request_json (str): PUT request in json format\n\n    Returns:\n        str: name of file object to be stored in MinIO\n    \"\"\"\n    # get current UTC time in format of %Y%m%d\n    dir_name = datetime.now(timezone.utc).strftime('%Y%m%d/')\n    # get current UTC hour in format of %H00\n    dir_name += datetime.now(timezone.utc).strftime('%H00/')\n    # get transaction number from the request\n    trans_num = json.loads(request_json).get(\"trans_num\")\n    # concatenate all the parts to form the file name\n    return f\"/{dir_name}/\" + f\"{trans_num}.txt\"\n</code></pre>"},{"location":"flask.fx.object_store/","title":"Object Store","text":"<p>This module provides functionality related to interacting with MinIO. It includes functions for connecting to a MinIO server, uploading files, and downloading files.</p>"},{"location":"flask.fx.object_store/#functions","title":"Functions:","text":"<ul> <li><code>get_minio_client</code>: Creates and returns a MinIO client based on the provided configuration.</li> <li><code>get_bucket</code>: Creates bucket in MinIO if bucket not found.</li> <li><code>put_json</code>: Jsonify a dict and write it as object to the bucket</li> </ul>"},{"location":"flask.fx.object_store/#src.flask_api.app.fx.object_store.get_minio_client","title":"<code>get_minio_client(endpoint_url=cfg.endpoint_url, username=cfg.user, password=cfg.password, secure=False)</code>","text":"<p>Create a MinIO client object.</p> <p>Creates an instance of the MinIO client object that can be used to interact with a MinIO server.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint_url</code> <code>str</code> <p>The URL of the MinIO server.</p> <code>endpoint_url</code> <code>username</code> <code>str</code> <p>The access key for the MinIO server.</p> <code>user</code> <code>password</code> <code>str</code> <p>The secret key for the MinIO server.</p> <code>password</code> <code>secure</code> <code>bool</code> <p>Whether to use secure communication with the MinIO server.</p> <code>False</code> <p>Returns:</p> Type Description <code>Minio</code> <p>An instance of the MinIO client object.</p> Source code in <code>src/flask_api/app/fx/object_store.py</code> <pre><code>def get_minio_client(\n    endpoint_url: str = cfg.endpoint_url,\n    username: str = cfg.user,\n    password: str = cfg.password,\n    secure: bool = False,\n) -&gt; Minio:\n    \"\"\"Create a MinIO client object.\n\n    Creates an instance of the MinIO client object that can be used to interact\n    with a MinIO server.\n\n    Args:\n        endpoint_url: The URL of the MinIO server.\n        username: The access key for the MinIO server.\n        password: The secret key for the MinIO server.\n        secure: Whether to use secure communication with the MinIO server.\n\n    Returns:\n        An instance of the MinIO client object.\n    \"\"\"\n    client = Minio(\n        endpoint=endpoint_url,\n        access_key=username,\n        secret_key=password,\n        secure=secure,\n    )\n    logger.debug(\n        \"Created an instance of Minio \"\n        f\"(endpoint={endpoint_url}, access_key={username}, \"\n        f\"secret_key={password}, secure={secure}): {client}\",\n    )\n    return client\n</code></pre>"},{"location":"flask.fx.object_store/#src.flask_api.app.fx.object_store.get_bucket","title":"<code>get_bucket(minio_client, bucket_name)</code>","text":"<p>Creates a bucket in MinIO with the given name if it does not already exist.</p> <p>Parameters:</p> Name Type Description Default <code>minio_client</code> <code>Minio</code> <p>MinIO client.</p> required <code>bucket_name</code> <code>str</code> <p>name of bucket.</p> required Source code in <code>src/flask_api/app/fx/object_store.py</code> <pre><code>def get_bucket(minio_client: Minio, bucket_name: str) -&gt; None:\n    \"\"\"\n    Creates a bucket in MinIO with the given name if it does not already exist.\n\n    Args:\n        minio_client (Minio): MinIO client.\n        bucket_name (str): name of bucket.\n    \"\"\"\n    logger.debug(f\"Checking if bucket '{bucket_name}' exists\")\n    found = minio_client.bucket_exists(bucket_name)\n    logger.debug(f\"Bucket '{bucket_name}' {'does' if found else 'does not'} exist\")\n    if not found:\n        logger.debug(f\"Creating bucket '{bucket_name}'\")\n        minio_client.make_bucket(bucket_name)\n        logger.success(f\"Created bucket '{bucket_name}'.\")\n    else:\n        logger.info(f\"Bucket '{bucket_name}' already exists.\")\n</code></pre>"},{"location":"flask.fx.object_store/#src.flask_api.app.fx.object_store.put_json","title":"<code>put_json(minio_client, bucket_name, object_name, d)</code>","text":"<p>Jsonify a dict and write it as object to the bucket</p> <p>This function jsonifies a dictionary, creates a BytesIO object from the json string, and uploads it as an object to the specified bucket using the MinIO client.</p> <p>Parameters:</p> Name Type Description Default <code>minio_client</code> <code>Minio</code> <p>MinIO Client</p> required <code>bucket_name</code> <code>str</code> <p>name of bucket</p> required <code>object_name</code> <code>str</code> <p>name of file object</p> required <code>d</code> <code>dict[str, Any]</code> <p>data in dictionary format</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>ObjectWriteResult</code> <p>The metadata of the uploaded object</p> Source code in <code>src/flask_api/app/fx/object_store.py</code> <pre><code>def put_json(\n    minio_client: \"Minio\",\n    bucket_name: str,\n    object_name: str,\n    d: dict[str, Any],\n) -&gt; ObjectWriteResult:\n    \"\"\"Jsonify a dict and write it as object to the bucket\n\n    This function jsonifies a dictionary, creates a BytesIO object from the\n    json string, and uploads it as an object to the specified bucket using\n    the MinIO client.\n\n    Args:\n        minio_client (Minio): MinIO Client\n        bucket_name (str): name of bucket\n        object_name (str): name of file object\n        d (dict[str, Any]): data in dictionary format\n\n    Returns:\n        dict: The metadata of the uploaded object\n    \"\"\"\n    # prepare data and corresponding data stream\n    data = json.dumps(d).encode(\"utf-8\")\n\n    byte_stream = io.BytesIO(data)\n    byte_stream.seek(0)\n\n    logger.success(\n        f\"Uploaded as object {object_name}\"\n        + f\" to bucket '{bucket_name}'\"\n    )\n\n    # put data as object into the bucket\n    return minio_client.put_object(\n        bucket_name=bucket_name,\n        object_name=object_name,\n        data=byte_stream,\n        length=len(data),\n        content_type=\"application/json\",\n    )\n</code></pre>"},{"location":"flask.fx.pubsub/","title":"PubSub","text":"<ul> <li>This module provides functions for interacting with Kafka in your application.   </li> <li>It includes methods for: <ul> <li>sending messages with or without keys to specific topics, </li> <li>creating and registering new topics in Kafka asynchronously, </li> <li>handling delivery reports, and </li> <li>managing AdminClient instances for Kafka topic management.   </li> </ul> </li> <li>This module helps facilitate communication through Kafka messaging in your application.</li> </ul>"},{"location":"flask.fx.pubsub/#functions","title":"Functions:","text":"<ul> <li>These functions handle different aspects of working with Kafka topics, messages, and delivery reports within your application.<ul> <li><code>_send_delivery_report</code>: Sends a delivery report based on the error and message received.</li> <li><code>extract_key</code>: Splits the specified key value from the rest of the dictionary.</li> <li><code>get_admin_client</code>: Creates an instance of AdminClient for managing Kafka topics.</li> <li><code>_create_topic</code>: Creates and registers a new topic in Kafka with a specified number of partitions and replication factor.</li> <li><code>_confirm_topic_creation</code>: Confirms that a topic creation was successful.</li> </ul> </li> </ul>"},{"location":"flask.fx.pubsub/#src.flask_api.app.fx.pubsub.AvroProducer","title":"<code>AvroProducer</code>  <code>dataclass</code>","text":"Source code in <code>src/flask_api/app/fx/pubsub.py</code> <pre><code>@dataclass\nclass AvroProducer:\n    kafka_brokers: str\n\n    def __post_init__(self) -&gt; None:\n        producer_config = {\n            \"bootstrap.servers\": self.kafka_brokers,\n            \"error_cb\": _error_callback_func,\n        }\n        self.producer = Producer(producer_config)\n        logger.debug(\n            \"Created an instance of AvroProducer(\"\n            + \", \".join(f\"{k}={v}\" for k, v in producer_config.items())\n            + f\"): {self.producer}\",\n        )\n\n    def set_avro_serializer(\n        self,\n        schema_str: Optional[str] = None,\n        class_object: Optional[Type] = None,\n    ) -&gt; \"AvroProducer\":\n        \"\"\"\n        Get value serializer from Schema Registry\n\n        This function gets the AvroSerializer from the Schema Registry\n        and assigns it as the value_serializer to be used for serializing\n        the event payload.\n\n        Args:\n            schema_str (str, optional): Avro Schema in json format.\n            class_object (Type, optional): Any dataclass or pydantic model\n            NOTE: Either `schema_str` or `class_object` must be provided.\n\n        Returns:\n            AvroProducer: Returns self to allow chaining of method calls.\n\n        Raises:\n            Exception: If both `schema_str` and `class_object` are provided,\n                or if neither is provided.\n        \"\"\"\n        schema_string = \"{}\"\n\n        if schema_str is not None and class_object is not None:\n            raise Exception(\n                \"Cannot pass both 'schema_str' and 'class_object'\"\n            )\n\n        if schema_str is None and class_object is None:\n            raise Exception(\"Must pass either 'schema_str' or 'class_object'\")\n\n        if class_object is not None:\n            schema_string = make_schema_str(class_object)\n\n\n        try:\n            sr_client = get_schema_registry_client()\n            self.value_serializer = sr_client.make_serializer(schema_str=schema_string)\n            logger.success(\"AvroSerializer set. AvroProducer ready to send messages.\")\n        except Exception as e:  \n            logger.exception(e)\n            raise Exception(f\"Failed to set AvroSerializer: {e}\")\n        finally:\n            return self\n\n    def send_message_with_key(\n        self,\n        topic: str,\n        payload: dict,\n        key: str,\n        poll_timeout_secs: float = 0.0,\n    ) -&gt; None:\n        \"\"\"\n        Send a message with a key to the specified topic.\n\n        Args:\n            topic (str): The name of the topic.\n            payload (dict): The event payload to send.\n            key (str): The key to send with the message.\n            poll_timeout_secs (float, optional): The polling timeout in seconds. Defaults to 0.5.\n\n        Returns:\n            None\n        \"\"\"\n        key, value = extract_key(payload=payload, key_field_name=key)\n        key_bytes = self._serialize_key(topic=topic, key=key)\n        value_bytes = self._serialize_value_payload(topic=topic, payload=value)\n\n        self.producer.produce(\n            topic=topic,\n            key=key_bytes,\n            value=value_bytes,\n            on_delivery=_send_delivery_report,\n        )\n\n        # Serve on_delivery callbacks from previous calls to produce()\n        self.producer.poll(timeout=poll_timeout_secs)\n\n    def send_message(\n        self,\n        topic: str,\n        payload: dict[str, Any],\n        poll_timeout_secs: float = 0.0,\n    ) -&gt; None:\n        \"\"\"\n        Send a message without a key to the specified topic.\n\n        Args:\n            topic (str): The name of the topic.\n            schema_str (str): Avro schema in json format\n            payload (dict): The event payload to send.\n            poll_timeout_secs (float, optional): The polling timeout in seconds. Defaults to 0.0.\n        \"\"\"\n        value_bytes = self._serialize_value_payload(topic=topic, payload=payload)\n\n        print('send')\n        self.producer.produce(\n            topic=topic,\n            value=value_bytes,\n            on_delivery=_send_delivery_report,\n        )\n\n        # Serve on_delivery callbacks from previous calls to produce()\n        self.producer.poll(timeout=poll_timeout_secs)\n\n    def _serialize_key(self, topic: str, key: str) -&gt; bytes | None:\n        \"\"\"\n        Serialize the key for the specified topic.\n\n        Args:\n            topic (str): The name of the topic.\n            key (str): The key to serialize.\n\n        Returns:\n            bytes | None: The serialized key.\n\n        Raises:\n            Exception: If serialization fails.\n        \"\"\"\n        try:\n            # Use StringSerializer from Confluent's Python Client to serialize the key\n            key_serializer = StringSerializer()\n            # Pass the topic, key, and the message field (KEY) to the serializer\n            return key_serializer(\n                key, \n                SerializationContext(topic, MessageField.KEY)\n            )\n        except Exception as e:\n            # Raise an exception with the error message\n            raise Exception(f\"Key serialization failed: {e}\") from e\n\n\n    def _serialize_value_payload(self, topic: str, payload: dict) -&gt; bytes | None:\n        \"\"\"\n        Serialize the event payload using the AvroSerializer.\n\n        Args:\n            topic (str): The name of the topic.\n            payload (dict): The event payload to send.\n\n        Returns:\n            bytes | None: The serialized event payload.\n\n        Raises:\n            Exception: If serialization fails.\n        \"\"\"\n        try:\n            print('serialize')\n            return self.value_serializer(\n                payload,\n                SerializationContext(topic, MessageField.VALUE),\n            )\n        except Exception as e:\n            raise Exception(f\"Serialization failed: {e}\") from e\n\n    def close(self) -&gt; None:\n        \"\"\"Prepare producer for a clean shutdown\n\n        Flush pending outbound events, wait for acknowledgement, and process callbacks.\n        \"\"\"\n        logger.info(\"Shutting down..\\nFlushing records...\")\n\n        # -1 is used to block until all messages are sent.\n        self.producer.flush(-1)\n</code></pre>"},{"location":"flask.fx.pubsub/#src.flask_api.app.fx.pubsub.AvroProducer.set_avro_serializer","title":"<code>set_avro_serializer(schema_str=None, class_object=None)</code>","text":"<p>Get value serializer from Schema Registry</p> <p>This function gets the AvroSerializer from the Schema Registry and assigns it as the value_serializer to be used for serializing the event payload.</p> <p>Parameters:</p> Name Type Description Default <code>schema_str</code> <code>str</code> <p>Avro Schema in json format.</p> <code>None</code> <code>class_object</code> <code>Type</code> <p>Any dataclass or pydantic model</p> <code>None</code> <code>NOTE</code> <p>Either <code>schema_str</code> or <code>class_object</code> must be provided.</p> required <p>Returns:</p> Name Type Description <code>AvroProducer</code> <code>AvroProducer</code> <p>Returns self to allow chaining of method calls.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If both <code>schema_str</code> and <code>class_object</code> are provided, or if neither is provided.</p> Source code in <code>src/flask_api/app/fx/pubsub.py</code> <pre><code>def set_avro_serializer(\n    self,\n    schema_str: Optional[str] = None,\n    class_object: Optional[Type] = None,\n) -&gt; \"AvroProducer\":\n    \"\"\"\n    Get value serializer from Schema Registry\n\n    This function gets the AvroSerializer from the Schema Registry\n    and assigns it as the value_serializer to be used for serializing\n    the event payload.\n\n    Args:\n        schema_str (str, optional): Avro Schema in json format.\n        class_object (Type, optional): Any dataclass or pydantic model\n        NOTE: Either `schema_str` or `class_object` must be provided.\n\n    Returns:\n        AvroProducer: Returns self to allow chaining of method calls.\n\n    Raises:\n        Exception: If both `schema_str` and `class_object` are provided,\n            or if neither is provided.\n    \"\"\"\n    schema_string = \"{}\"\n\n    if schema_str is not None and class_object is not None:\n        raise Exception(\n            \"Cannot pass both 'schema_str' and 'class_object'\"\n        )\n\n    if schema_str is None and class_object is None:\n        raise Exception(\"Must pass either 'schema_str' or 'class_object'\")\n\n    if class_object is not None:\n        schema_string = make_schema_str(class_object)\n\n\n    try:\n        sr_client = get_schema_registry_client()\n        self.value_serializer = sr_client.make_serializer(schema_str=schema_string)\n        logger.success(\"AvroSerializer set. AvroProducer ready to send messages.\")\n    except Exception as e:  \n        logger.exception(e)\n        raise Exception(f\"Failed to set AvroSerializer: {e}\")\n    finally:\n        return self\n</code></pre>"},{"location":"flask.fx.pubsub/#src.flask_api.app.fx.pubsub.AvroProducer.send_message_with_key","title":"<code>send_message_with_key(topic, payload, key, poll_timeout_secs=0.0)</code>","text":"<p>Send a message with a key to the specified topic.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str</code> <p>The name of the topic.</p> required <code>payload</code> <code>dict</code> <p>The event payload to send.</p> required <code>key</code> <code>str</code> <p>The key to send with the message.</p> required <code>poll_timeout_secs</code> <code>float</code> <p>The polling timeout in seconds. Defaults to 0.5.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/flask_api/app/fx/pubsub.py</code> <pre><code>def send_message_with_key(\n    self,\n    topic: str,\n    payload: dict,\n    key: str,\n    poll_timeout_secs: float = 0.0,\n) -&gt; None:\n    \"\"\"\n    Send a message with a key to the specified topic.\n\n    Args:\n        topic (str): The name of the topic.\n        payload (dict): The event payload to send.\n        key (str): The key to send with the message.\n        poll_timeout_secs (float, optional): The polling timeout in seconds. Defaults to 0.5.\n\n    Returns:\n        None\n    \"\"\"\n    key, value = extract_key(payload=payload, key_field_name=key)\n    key_bytes = self._serialize_key(topic=topic, key=key)\n    value_bytes = self._serialize_value_payload(topic=topic, payload=value)\n\n    self.producer.produce(\n        topic=topic,\n        key=key_bytes,\n        value=value_bytes,\n        on_delivery=_send_delivery_report,\n    )\n\n    # Serve on_delivery callbacks from previous calls to produce()\n    self.producer.poll(timeout=poll_timeout_secs)\n</code></pre>"},{"location":"flask.fx.pubsub/#src.flask_api.app.fx.pubsub.AvroProducer.send_message","title":"<code>send_message(topic, payload, poll_timeout_secs=0.0)</code>","text":"<p>Send a message without a key to the specified topic.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str</code> <p>The name of the topic.</p> required <code>schema_str</code> <code>str</code> <p>Avro schema in json format</p> required <code>payload</code> <code>dict</code> <p>The event payload to send.</p> required <code>poll_timeout_secs</code> <code>float</code> <p>The polling timeout in seconds. Defaults to 0.0.</p> <code>0.0</code> Source code in <code>src/flask_api/app/fx/pubsub.py</code> <pre><code>def send_message(\n    self,\n    topic: str,\n    payload: dict[str, Any],\n    poll_timeout_secs: float = 0.0,\n) -&gt; None:\n    \"\"\"\n    Send a message without a key to the specified topic.\n\n    Args:\n        topic (str): The name of the topic.\n        schema_str (str): Avro schema in json format\n        payload (dict): The event payload to send.\n        poll_timeout_secs (float, optional): The polling timeout in seconds. Defaults to 0.0.\n    \"\"\"\n    value_bytes = self._serialize_value_payload(topic=topic, payload=payload)\n\n    print('send')\n    self.producer.produce(\n        topic=topic,\n        value=value_bytes,\n        on_delivery=_send_delivery_report,\n    )\n\n    # Serve on_delivery callbacks from previous calls to produce()\n    self.producer.poll(timeout=poll_timeout_secs)\n</code></pre>"},{"location":"flask.fx.pubsub/#src.flask_api.app.fx.pubsub.AvroProducer.close","title":"<code>close()</code>","text":"<p>Prepare producer for a clean shutdown</p> <p>Flush pending outbound events, wait for acknowledgement, and process callbacks.</p> Source code in <code>src/flask_api/app/fx/pubsub.py</code> <pre><code>def close(self) -&gt; None:\n    \"\"\"Prepare producer for a clean shutdown\n\n    Flush pending outbound events, wait for acknowledgement, and process callbacks.\n    \"\"\"\n    logger.info(\"Shutting down..\\nFlushing records...\")\n\n    # -1 is used to block until all messages are sent.\n    self.producer.flush(-1)\n</code></pre>"},{"location":"flask.fx.pubsub/#src.flask_api.app.fx.pubsub.get_avro_producer","title":"<code>get_avro_producer(kafka_brokers=cfg.bootstrap_servers)</code>","text":"<p>Create an instance of AvroProducer</p> <p>Parameters:</p> Name Type Description Default <code>kafka_brokers</code> <code>str</code> <p>description. Defaults to cfg.bootstrap_servers.</p> <code>bootstrap_servers</code> <p>Returns:</p> Name Type Description <code>AvroProducer</code> <code>AvroProducer</code> <p>description</p> Source code in <code>src/flask_api/app/fx/pubsub.py</code> <pre><code>def get_avro_producer(kafka_brokers:str=cfg.bootstrap_servers) -&gt; AvroProducer:\n    \"\"\"Create an instance of AvroProducer\n\n    Args:\n        kafka_brokers (str, optional): _description_. Defaults to cfg.bootstrap_servers.\n\n    Returns:\n        AvroProducer: _description_\n    \"\"\"\n    if not confluent_kafka:\n        logger.error(\"Cannot create producer. Confluent-kafka package not available.\")\n\n    return AvroProducer(kafka_brokers=kafka_brokers)\n</code></pre>"},{"location":"flask.fx.pubsub/#src.flask_api.app.fx.pubsub.extract_key","title":"<code>extract_key(payload, key_field_name)</code>","text":"<p>Splits the specified key value from the rest of the dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>dict</code> <p>Dictionary containing the key value.</p> required <code>key_field_name</code> <code>str</code> <p>Name of key field.</p> required <p>Returns:</p> Type Description <code>str</code> <p>tuple[str, dict[str, Any]]: A tuple containing the key value and the</p> <code>dict[str, Any]</code> <p>remaining dictionary with the key field removed.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If payload is not a dictionary.</p> <code>Exception</code> <p>If the key field is not found in the payload.</p> Source code in <code>src/flask_api/app/fx/pubsub.py</code> <pre><code>def extract_key(payload: dict, key_field_name: str) -&gt; tuple[str, dict[str, Any]]:\n    \"\"\"Splits the specified key value from the rest of the dictionary.\n\n    Args:\n        payload (dict): Dictionary containing the key value.\n        key_field_name (str): Name of key field.\n\n    Returns:\n        tuple[str, dict[str, Any]]: A tuple containing the key value and the\n        remaining dictionary with the key field removed.\n\n    Raises:\n        Exception: If payload is not a dictionary.\n        Exception: If the key field is not found in the payload.\n    \"\"\"\n    if not isinstance(payload, dict):\n        raise Exception(\"The input for 'payload' must be a dictionary.\")\n\n    if payload.get(key_field_name, None) is None:\n        raise Exception(f\"Could not find '{key_field_name}' in payload dictionary\")\n\n    key_value = payload.pop(key_field_name)\n    return str(key_value), payload\n</code></pre>"},{"location":"flask.fx.pubsub/#src.flask_api.app.fx.pubsub.get_admin_client","title":"<code>get_admin_client(kafka_brokers=cfg.bootstrap_servers)</code>","text":"<p>Create an instance of AdminClient.</p> <p>This function creates an instance of AdminClient using the supplied list of kafka brokers. If no brokers are provided, it uses the default bootstrap servers from the config.</p> <p>Parameters:</p> Name Type Description Default <code>kafka_brokers</code> <code>str</code> <p>A comma separated list of kafka brokers. Defaults to the value specified in the config.</p> <code>bootstrap_servers</code> <p>Returns:</p> Name Type Description <code>AdminClient</code> <code>AdminClient</code> <p>An instance of AdminClient.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the confluent_kafka package is not available.</p> Source code in <code>src/flask_api/app/fx/pubsub.py</code> <pre><code>def get_admin_client(kafka_brokers: str = cfg.bootstrap_servers) -&gt; AdminClient:\n    \"\"\"\n    Create an instance of AdminClient.\n\n    This function creates an instance of AdminClient using the supplied\n    list of kafka brokers. If no brokers are provided, it uses the default\n    bootstrap servers from the config.\n\n    Args:\n        kafka_brokers (str): A comma separated list of kafka brokers.\n            Defaults to the value specified in the config.\n\n    Returns:\n        AdminClient: An instance of AdminClient.\n\n    Raises:\n        Exception: If the confluent_kafka package is not available.\n    \"\"\"\n    if not confluent_kafka:\n        logger.error(\n            \"Cannot create producer. Confluent-kafka package not available.\"\n        )\n\n    return AdminClient({\"bootstrap.servers\": kafka_brokers})\n</code></pre>"},{"location":"flask.fx.pubsub/#src.flask_api.app.fx.pubsub.create_topic","title":"<code>create_topic(client, topic)</code>","text":"<p>Creates Kafka topic if it does not exist.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>AdminClient</code> <p>AdminClient instance.</p> required <code>topic</code> <code>str</code> <p>Name of the topic to create.</p> required Source code in <code>src/flask_api/app/fx/pubsub.py</code> <pre><code>def create_topic(client: AdminClient, topic: str) -&gt; None:\n    \"\"\"Creates Kafka topic if it does not exist.\n\n    Args:\n        client (AdminClient): AdminClient instance.\n        topic (str): Name of the topic to create.\n    \"\"\"\n    # probe to check if topic is set up\n    if not _topic_exists(client, topic):\n        # create topic if not exists\n        _create_topic(client, topic)\n</code></pre>"},{"location":"flask.fx.registry/","title":"Registry","text":"<p>This module serves as a central component for interacting with the Confluent Schema Registry.  </p> <p>It encapsulates functions for registering, retrieving, and managing schemas, making it easier to work with schema validation and evolution in your application.  </p>"},{"location":"flask.fx.registry/#src.flask_api.app.fx.registry.SchemaRegistry","title":"<code>SchemaRegistry</code>  <code>dataclass</code>","text":"<p>Schema Registry</p> <p>This class provides a wrapper around the Confluent Schema Registry client to make it easier to use.</p> Source code in <code>src/flask_api/app/fx/registry.py</code> <pre><code>@dataclass\nclass SchemaRegistry:\n    \"\"\"Schema Registry\n\n    This class provides a wrapper around the Confluent Schema Registry\n    client to make it easier to use.\n    \"\"\"\n\n    endpoint_url: str\n\n\n    def __post_init__(self) -&gt; None:\n        schema_config = {\n            \"url\": self.endpoint_url,\n        }\n        self.sr_client = SchemaRegistryClient(schema_config)\n\n        logger.debug(\"Created an instance of SchemaRegistry(\"\n                + f\"endpoint_url={self.endpoint_url}): {self.sr_client}\",\n        )\n\n    # TODO: What if schema_str is just a string and not valid schema_str\n    def register_schema(\n        self,\n        topic: str,\n        schema_str: Optional[str] = None,\n        class_object: Optional[Type] = None,\n    ) -&gt; Optional[int]:\n        \"\"\"\n        Register a schema with the schema registry using the topic name\n        and either a schema_str or class_object.\n\n        Args:\n            topic (str): Kafka topic name\n            schema_str (str, optional): Avro schema in json format.\n            class_object (Type, optional): Any dataclass or pydantic model.\n                NOTE: Either `schema_str` or `class_object` must be provided.\n\n        Returns:\n            int: The id of the registered schema\n\n        Raises:\n            Exception: If both `schema_str` and `class_object` are provided,\n                or if neither is provided.\n        \"\"\"\n        try:\n            schema_id = None\n            object_name = None\n\n            if schema_str is not None and class_object is not None:\n                raise Exception(\n                    \"Cannot pass both 'schema_str' and 'class_object'\"\n                )\n\n            if schema_str is None and class_object is None:\n                raise Exception(\"Must pass either 'schema_str' or 'class_object'\")\n\n            if class_object is not None:\n                schema_str = make_schema_str(class_object)\n                object_name = class_object.__name__\n\n            new_schema = Schema(schema_str, schema_type=SCHEMA_TYPE)\n            schema_id = self.sr_client.register_schema(\n                subject_name=get_subject_name(topic), schema=new_schema\n            )\n            if object_name:\n                logger.success(f\"Registered schema for {object_name}...\")\n            else:\n                logger.success(\"Registered schema...\")\n\n        except SchemaRegistryError as e:\n            logger.exception(e)\n            return None\n        finally:\n            return schema_id\n\n\n\n\n    def _delete_subject(self, topic: str) -&gt; list:\n        \"\"\"Delete all versions of a schema\n\n        Args:\n            topic (str): Kafka topic name\n\n        Returns:\n            list: List of ids of deleted versions\n        \"\"\"\n        return self.sr_client.delete_subject(get_subject_name(topic))\n\n\n    # TODO: check return type\n    def update_schema(self, topic: str, schema_str: str) -&gt; Optional[int]:\n        \"\"\"Update the schema for a topic\n\n        This will first delete all versions of the schema and then\n        register the new schema.\n\n        Args:\n            topic (str): Kafka topic name\n            schema_str (str): Avro schema in json format\n\n        Returns:\n            int: The id of the registered schema\n        \"\"\"\n        versions_deleted_list = self._delete_subject(topic)\n        logger.info(\"versions of schema deleted list:\", versions_deleted_list)\n        return self.register_schema(topic, schema_str)\n\n    @logger.catch\n    def get_schema(self, topic: str) -&gt; str:\n        \"\"\"Get the latest schema for a topic\n\n        Args:\n            topic (str): Kafka topic name\n\n        Returns:\n            str: The latest schema in json format\n        \"\"\"\n        latest_schema = self.sr_client.get_latest_version(\n            get_subject_name(topic),\n        )\n        return latest_schema.schema.schema_str\n\n    def make_serializer(self, schema_str: str) -&gt; AvroSerializer:\n        \"\"\"Create avro_serializer that is correctly configured\n\n        Args:\n            schema_str (str): avro schema in json format\n\n        Returns:\n            AvroSerializer: _description_\n        \"\"\"\n        try:\n            return AvroSerializer(\n                schema_registry_client=self.sr_client,\n                schema_str=schema_str,\n                conf={\"auto.register.schemas\": False},\n            )\n        except SchemaRegistryError as e: \n            logger.exception(e)\n            raise Exception(f\"Failed to create serializer: {e}\")\n\n    def make_deserializer(self, schema_str: str) -&gt; AvroDeserializer:\n        \"\"\"Create avro_deserializer that is correctly configured\n\n        Args:\n            schema_str (str): avro schema in json format\n\n        Returns:\n            AvroDeserializer: _description_\n        \"\"\"\n        try:\n            return AvroDeserializer(\n                schema_registry_client=self.sr_client, schema_str=schema_str\n            )\n        except SchemaRegistryError as e:\n            logger.exception(e)\n            raise Exception(f\"Failed to create deserializer: {e}\")    \n</code></pre>"},{"location":"flask.fx.registry/#src.flask_api.app.fx.registry.SchemaRegistry.register_schema","title":"<code>register_schema(topic, schema_str=None, class_object=None)</code>","text":"<p>Register a schema with the schema registry using the topic name and either a schema_str or class_object.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str</code> <p>Kafka topic name</p> required <code>schema_str</code> <code>str</code> <p>Avro schema in json format.</p> <code>None</code> <code>class_object</code> <code>Type</code> <p>Any dataclass or pydantic model. NOTE: Either <code>schema_str</code> or <code>class_object</code> must be provided.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>Optional[int]</code> <p>The id of the registered schema</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If both <code>schema_str</code> and <code>class_object</code> are provided, or if neither is provided.</p> Source code in <code>src/flask_api/app/fx/registry.py</code> <pre><code>def register_schema(\n    self,\n    topic: str,\n    schema_str: Optional[str] = None,\n    class_object: Optional[Type] = None,\n) -&gt; Optional[int]:\n    \"\"\"\n    Register a schema with the schema registry using the topic name\n    and either a schema_str or class_object.\n\n    Args:\n        topic (str): Kafka topic name\n        schema_str (str, optional): Avro schema in json format.\n        class_object (Type, optional): Any dataclass or pydantic model.\n            NOTE: Either `schema_str` or `class_object` must be provided.\n\n    Returns:\n        int: The id of the registered schema\n\n    Raises:\n        Exception: If both `schema_str` and `class_object` are provided,\n            or if neither is provided.\n    \"\"\"\n    try:\n        schema_id = None\n        object_name = None\n\n        if schema_str is not None and class_object is not None:\n            raise Exception(\n                \"Cannot pass both 'schema_str' and 'class_object'\"\n            )\n\n        if schema_str is None and class_object is None:\n            raise Exception(\"Must pass either 'schema_str' or 'class_object'\")\n\n        if class_object is not None:\n            schema_str = make_schema_str(class_object)\n            object_name = class_object.__name__\n\n        new_schema = Schema(schema_str, schema_type=SCHEMA_TYPE)\n        schema_id = self.sr_client.register_schema(\n            subject_name=get_subject_name(topic), schema=new_schema\n        )\n        if object_name:\n            logger.success(f\"Registered schema for {object_name}...\")\n        else:\n            logger.success(\"Registered schema...\")\n\n    except SchemaRegistryError as e:\n        logger.exception(e)\n        return None\n    finally:\n        return schema_id\n</code></pre>"},{"location":"flask.fx.registry/#src.flask_api.app.fx.registry.SchemaRegistry.update_schema","title":"<code>update_schema(topic, schema_str)</code>","text":"<p>Update the schema for a topic</p> <p>This will first delete all versions of the schema and then register the new schema.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str</code> <p>Kafka topic name</p> required <code>schema_str</code> <code>str</code> <p>Avro schema in json format</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>Optional[int]</code> <p>The id of the registered schema</p> Source code in <code>src/flask_api/app/fx/registry.py</code> <pre><code>def update_schema(self, topic: str, schema_str: str) -&gt; Optional[int]:\n    \"\"\"Update the schema for a topic\n\n    This will first delete all versions of the schema and then\n    register the new schema.\n\n    Args:\n        topic (str): Kafka topic name\n        schema_str (str): Avro schema in json format\n\n    Returns:\n        int: The id of the registered schema\n    \"\"\"\n    versions_deleted_list = self._delete_subject(topic)\n    logger.info(\"versions of schema deleted list:\", versions_deleted_list)\n    return self.register_schema(topic, schema_str)\n</code></pre>"},{"location":"flask.fx.registry/#src.flask_api.app.fx.registry.SchemaRegistry.get_schema","title":"<code>get_schema(topic)</code>","text":"<p>Get the latest schema for a topic</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str</code> <p>Kafka topic name</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The latest schema in json format</p> Source code in <code>src/flask_api/app/fx/registry.py</code> <pre><code>@logger.catch\ndef get_schema(self, topic: str) -&gt; str:\n    \"\"\"Get the latest schema for a topic\n\n    Args:\n        topic (str): Kafka topic name\n\n    Returns:\n        str: The latest schema in json format\n    \"\"\"\n    latest_schema = self.sr_client.get_latest_version(\n        get_subject_name(topic),\n    )\n    return latest_schema.schema.schema_str\n</code></pre>"},{"location":"flask.fx.registry/#src.flask_api.app.fx.registry.SchemaRegistry.make_serializer","title":"<code>make_serializer(schema_str)</code>","text":"<p>Create avro_serializer that is correctly configured</p> <p>Parameters:</p> Name Type Description Default <code>schema_str</code> <code>str</code> <p>avro schema in json format</p> required <p>Returns:</p> Name Type Description <code>AvroSerializer</code> <code>AvroSerializer</code> <p>description</p> Source code in <code>src/flask_api/app/fx/registry.py</code> <pre><code>def make_serializer(self, schema_str: str) -&gt; AvroSerializer:\n    \"\"\"Create avro_serializer that is correctly configured\n\n    Args:\n        schema_str (str): avro schema in json format\n\n    Returns:\n        AvroSerializer: _description_\n    \"\"\"\n    try:\n        return AvroSerializer(\n            schema_registry_client=self.sr_client,\n            schema_str=schema_str,\n            conf={\"auto.register.schemas\": False},\n        )\n    except SchemaRegistryError as e: \n        logger.exception(e)\n        raise Exception(f\"Failed to create serializer: {e}\")\n</code></pre>"},{"location":"flask.fx.registry/#src.flask_api.app.fx.registry.SchemaRegistry.make_deserializer","title":"<code>make_deserializer(schema_str)</code>","text":"<p>Create avro_deserializer that is correctly configured</p> <p>Parameters:</p> Name Type Description Default <code>schema_str</code> <code>str</code> <p>avro schema in json format</p> required <p>Returns:</p> Name Type Description <code>AvroDeserializer</code> <code>AvroDeserializer</code> <p>description</p> Source code in <code>src/flask_api/app/fx/registry.py</code> <pre><code>def make_deserializer(self, schema_str: str) -&gt; AvroDeserializer:\n    \"\"\"Create avro_deserializer that is correctly configured\n\n    Args:\n        schema_str (str): avro schema in json format\n\n    Returns:\n        AvroDeserializer: _description_\n    \"\"\"\n    try:\n        return AvroDeserializer(\n            schema_registry_client=self.sr_client, schema_str=schema_str\n        )\n    except SchemaRegistryError as e:\n        logger.exception(e)\n        raise Exception(f\"Failed to create deserializer: {e}\")    \n</code></pre>"},{"location":"flask.fx.registry/#src.flask_api.app.fx.registry.get_subject_name","title":"<code>get_subject_name(topic)</code>","text":"<p>Get the subject name for a given topic.</p> <p>Parameters:</p> Name Type Description Default <code>topic</code> <code>str</code> <p>The topic for which to get the subject name.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The subject name derived from the topic.</p> Source code in <code>src/flask_api/app/fx/registry.py</code> <pre><code>def get_subject_name(topic: str) -&gt; str:\n    \"\"\"\n    Get the subject name for a given topic.\n\n    Args:\n        topic (str): The topic for which to get the subject name.\n\n    Returns:\n        str: The subject name derived from the topic.\n    \"\"\"\n    return f\"{topic}-value\"\n</code></pre>"},{"location":"flask.fx.registry/#src.flask_api.app.fx.registry.make_schema_str","title":"<code>make_schema_str(class_object)</code>","text":"<p>Generate Avro schema in JSON format from a Python class object.</p> <p>This function uses the py_avro_schema library to generate an Avro schema from a Python class object. The schema is returned in JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>class_object</code> <code>Type</code> <p>The Python class to generate a schema for.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The Avro schema in JSON format.</p> Source code in <code>src/flask_api/app/fx/registry.py</code> <pre><code>def make_schema_str(class_object: Type) -&gt; str:\n    \"\"\"\n    Generate Avro schema in JSON format from a Python class object.\n\n    This function uses the py_avro_schema library to generate an Avro schema\n    from a Python class object. The schema is returned in JSON format.\n\n    Args:\n        class_object (Type): The Python class to generate a schema for.\n\n    Returns:\n        str: The Avro schema in JSON format.\n    \"\"\"\n    try:\n        # Use the py_avro_schema library to generate an Avro schema\n        # from the class object.\n        schema_bytes = pas.generate(\n            class_object,\n            # Use JSON indent of 2 and no auto namespace\n            options=pas.Option.JSON_INDENT_2 | pas.Option.NO_AUTO_NAMESPACE,\n        )\n        # Decode the bytes to a string\n        return schema_bytes.decode()\n    except Exception as e:\n        logger.exception(e)\n        raise Exception(f\"Failed to generate schema: {e}\")\n</code></pre>"},{"location":"flask.fx.registry/#src.flask_api.app.fx.registry.get_schema_registry_client","title":"<code>get_schema_registry_client(endpoint_url=cfg.endpoint_url)</code>","text":"<p>Create an instance of SchemaRegistry</p> <p>This function creates an instance of the SchemaRegistry class using the endpoint_url as the URL of the Schema Registry.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint_url</code> <code>str</code> <p>The URL of the Schema Registry. Defaults to cfg.endpoint_url.</p> <code>endpoint_url</code> <p>Returns:</p> Name Type Description <code>SchemaRegistry</code> <code>SchemaRegistry</code> <p>An instance of SchemaRegistry.</p> Source code in <code>src/flask_api/app/fx/registry.py</code> <pre><code>def get_schema_registry_client(\n        endpoint_url: str = cfg.endpoint_url,\n) -&gt; \"SchemaRegistry\":\n    \"\"\"Create an instance of SchemaRegistry\n\n    This function creates an instance of the SchemaRegistry class\n    using the endpoint_url as the URL of the Schema Registry.\n\n    Args:\n        endpoint_url (str, optional): The URL of the Schema Registry.\n            Defaults to cfg.endpoint_url.\n\n    Returns:\n        SchemaRegistry: An instance of SchemaRegistry.\n    \"\"\"\n    return SchemaRegistry(endpoint_url=endpoint_url)\n</code></pre>"},{"location":"flask.utils.log/","title":"Log","text":""},{"location":"flask.utils.log/#settings","title":"Settings","text":""},{"location":"flask.utils.log/#src.flask_api.app.utils.log.get_logger","title":"<code>get_logger()</code>","text":"<p>Create and configure a Logger instance from loguru.</p> <p>Returns:</p> Name Type Description <code>Logger</code> <p>A Logger instance with the configured settings.</p> Source code in <code>src/flask_api/app/utils/log.py</code> <pre><code>def get_logger():\n    \"\"\"\n    Create and configure a Logger instance from loguru.\n\n    Returns:\n        Logger: A Logger instance with the configured settings.\n    \"\"\"\n    lg.remove()\n    # Add a new handler that logs to sys.stderr\n    lg.add(\n        sys.stderr,\n        # Logging level\n        level=os.getenv('LOG_LEVEL', 'INFO'),\n        # Logging format\n        format=logger_format,\n        # Colorize the output\n        colorize=True,\n        # Do not serialize the log records\n        serialize=False,\n    )\n    print(lg)\n    return lg\n</code></pre>"},{"location":"flask.utils.settings/","title":"Settings","text":""},{"location":"flask.utils.settings/#settings","title":"Settings","text":""},{"location":"flask.utils.settings/#src.flask_api.app.utils.settings.APIConfig","title":"<code>APIConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Configuration for the API</p> <p>Attributes:</p> Name Type Description <code>port</code> <code>int</code> <p>The port number to listen on.</p> <code>endpoint</code> <code>str</code> <p>The endpoint to serve the API on.</p> <code>API_TITLE</code> <code>str</code> <p>The title of the API.</p> <code>API_VERSION</code> <code>str</code> <p>The version of the API.</p> <code>OPENAPI_VERSION</code> <code>str</code> <p>The version of the OpenAPI specs to use. Defaults to \"3.0.3\".</p> <code>OPENAPI_URL_PREFIX</code> <code>str</code> <p>The URL prefix for the OpenAPI specs. Defaults to \"/\".</p> <code>OPENAPI_SWAGGER_UI_PATH</code> <code>str</code> <p>The path for the Swagger UI. Defaults to \"/swagger-ui\".</p> <code>OPENAPI_SWAGGER_UI_URL</code> <code>str</code> <p>The URL for the Swagger UI. Defaults to \"https://cdn.jsdelivr.net/npm/swagger-ui-dist/\".</p> <code>OPENAPI_REDOC_PATH</code> <code>str</code> <p>The path for the ReDoc UI. Defaults to \"/REDOC\".</p> <code>OPENAPI_REDOC_UI_URL</code> <code>str</code> <p>The URL for the ReDoc UI. Defaults to \"https://cdn.jsdelivr.net/npm/redoc@next/bundles/redoc.standalone.js\".</p> <code>CONFIG_SOURCES</code> <code>list</code> <p>The configuration sources to use.</p> Source code in <code>src/flask_api/app/utils/settings.py</code> <pre><code>class APIConfig(BaseConfig):\n    \"\"\"\n    Configuration for the API\n\n    Attributes:\n        port (int): The port number to listen on.\n        endpoint (str): The endpoint to serve the API on.\n\n        # OpenAPI Specs\n        API_TITLE (str): The title of the API.\n        API_VERSION (str): The version of the API.\n        OPENAPI_VERSION (str): The version of the OpenAPI specs to use.\n            Defaults to \"3.0.3\".\n        OPENAPI_URL_PREFIX (str): The URL prefix for the OpenAPI specs.\n            Defaults to \"/\".\n        OPENAPI_SWAGGER_UI_PATH (str): The path for the Swagger UI.\n            Defaults to \"/swagger-ui\".\n        OPENAPI_SWAGGER_UI_URL (str): The URL for the Swagger UI.\n            Defaults to \"https://cdn.jsdelivr.net/npm/swagger-ui-dist/\".\n        OPENAPI_REDOC_PATH (str): The path for the ReDoc UI.\n            Defaults to \"/REDOC\".\n        OPENAPI_REDOC_UI_URL (str): The URL for the ReDoc UI.\n            Defaults to \"https://cdn.jsdelivr.net/npm/redoc@next/bundles/redoc.standalone.js\".\n\n        CONFIG_SOURCES (list): The configuration sources to use.\n    \"\"\"\n    port: int\n    endpoint: str\n\n    # OpenAPI Specs\n    API_TITLE: str\n    API_VERSION: str\n    OPENAPI_VERSION: str = \"3.0.3\"\n    OPENAPI_URL_PREFIX: str = \"/\"\n    OPENAPI_SWAGGER_UI_PATH: str = \"/swagger-ui\"\n    OPENAPI_SWAGGER_UI_URL: str = (\n        \"https://cdn.jsdelivr.net/npm/swagger-ui-dist/\"  # noqa E501\n    )\n    OPENAPI_REDOC_PATH: str = \"/REDOC\"\n    OPENAPI_REDOC_UI_URL: str = (\n        \"https://cdn.jsdelivr.net/npm/redoc@next/bundles/redoc.standalone.js\"\n    )\n\n    CONFIG_SOURCES = [\n        EnvSource(\n            allow_all=True,\n            prefix=\"API_\",\n            file=ENV_FILE,\n            nested_separator=ENV_NESTED_SEP,\n            remap={\n                \"API_TITLE\": \"API_TITLE\",\n                \"API_VERSION\": \"API_VERSION\",\n            },\n        )\n    ]\n</code></pre>"},{"location":"flask.utils.settings/#src.flask_api.app.utils.settings.MinioConfig","title":"<code>MinioConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>MinIO Configuration</p> <p>Configuration for MinIO.</p> <p>Attributes:</p> Name Type Description <code>hostname</code> <code>str</code> <p>The hostname of the MinIO server</p> <code>port</code> <code>int</code> <p>The port of the MinIO server</p> <code>user</code> <code>str</code> <p>The root user of the MinIO server</p> <code>password</code> <code>str</code> <p>The root password of the MinIO server</p> Source code in <code>src/flask_api/app/utils/settings.py</code> <pre><code>class MinioConfig(BaseConfig):\n    \"\"\"MinIO Configuration\n\n    Configuration for MinIO.\n\n    Attributes:\n        hostname (str): The hostname of the MinIO server\n        port (int): The port of the MinIO server\n        user (str): The root user of the MinIO server\n        password (str): The root password of the MinIO server\n    \"\"\"\n    hostname: str\n    port: int\n    user: str = Field(min_length=3, description=\"The root user of the MinIO server\")\n    password: str = Field(min_length=8, description=\"The root password of the MinIO server\")\n\n    CONFIG_SOURCES = EnvSource(\n        allow_all=True,\n        prefix=\"MINIO_\",\n        file=ENV_FILE,\n        nested_separator=ENV_NESTED_SEP,\n        remap={\n            \"ROOT_USER\": \"user\",\n            \"ROOT_PASSWORD\": \"password\",\n        },\n    )\n\n    @property\n    def endpoint_url(self) -&gt; str:\n        \"\"\"The endpoint URL of the MinIO server\n\n        If we are running in Docker, return the hostname and port.\n        Otherwise, return the localhost and port.\n\n        Returns:\n            str: The endpoint URL of the MinIO server\n        \"\"\"\n        if _running_in_docker():\n            return f\"{self.hostname}:{str(self.port)}\"\n        else:\n            return f\"localhost:{str(self.port)}\"\n</code></pre>"},{"location":"flask.utils.settings/#src.flask_api.app.utils.settings.MinioConfig.endpoint_url","title":"<code>endpoint_url: str</code>  <code>property</code>","text":"<p>The endpoint URL of the MinIO server</p> <p>If we are running in Docker, return the hostname and port. Otherwise, return the localhost and port.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The endpoint URL of the MinIO server</p>"},{"location":"flask.utils.settings/#src.flask_api.app.utils.settings.SchemaRegistryConfig","title":"<code>SchemaRegistryConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Schema Registry Configuration</p> <p>Configuration for the Confluent Schema Registry.</p> <p>Attributes:</p> Name Type Description <code>hostname</code> <code>str</code> <p>The hostname of the Schema Registry server</p> <code>port</code> <code>int</code> <p>The port of the Schema Registry server</p> Source code in <code>src/flask_api/app/utils/settings.py</code> <pre><code>class SchemaRegistryConfig(BaseConfig):\n    \"\"\"Schema Registry Configuration\n\n    Configuration for the Confluent Schema Registry.\n\n    Attributes:\n        hostname (str): The hostname of the Schema Registry server\n        port (int): The port of the Schema Registry server\n    \"\"\"\n    hostname: str\n    port: int\n\n    CONFIG_SOURCES = [\n        EnvSource(\n            allow_all=True,\n            prefix=\"SR_\",\n            file=ENV_FILE,\n            nested_separator=ENV_NESTED_SEP,\n        )\n    ]\n\n    @property\n    def endpoint_url(self) -&gt; str:\n        \"\"\"The endpoint URL of the Schema Registry server\n\n        If we are running in Docker, return the hostname and port.\n        Otherwise, return the localhost and port.\n\n        Returns:\n            str: The endpoint URL of the Schema Registry server\n        \"\"\"\n        if _running_in_docker():\n            return f\"http://{self.hostname}:{str(self.port)}\"\n        else:\n            return f\"http://localhost:{str(self.port)}\"\n</code></pre>"},{"location":"flask.utils.settings/#src.flask_api.app.utils.settings.SchemaRegistryConfig.endpoint_url","title":"<code>endpoint_url: str</code>  <code>property</code>","text":"<p>The endpoint URL of the Schema Registry server</p> <p>If we are running in Docker, return the hostname and port. Otherwise, return the localhost and port.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The endpoint URL of the Schema Registry server</p>"},{"location":"flask.utils.settings/#src.flask_api.app.utils.settings.KafkaConfig","title":"<code>KafkaConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Kafka Configuration</p> <p>Configuration for Kafka.</p> <p>Attributes:</p> Name Type Description <code>broker_name</code> <code>str</code> <p>The name of the Kafka broker</p> <code>broker_port</code> <code>int</code> <p>The port of the Kafka broker</p> <code>topic</code> <code>str</code> <p>The Kafka topic to use</p> Source code in <code>src/flask_api/app/utils/settings.py</code> <pre><code>class KafkaConfig(BaseConfig):\n    \"\"\"Kafka Configuration\n\n    Configuration for Kafka.\n\n    Attributes:\n        broker_name (str): The name of the Kafka broker\n        broker_port (int): The port of the Kafka broker\n        topic (str): The Kafka topic to use\n    \"\"\"\n    broker_name: str\n    broker_port: int\n    topic: str\n\n    CONFIG_SOURCES = EnvSource(\n        allow_all=True,\n        prefix=\"KAFKA_\",\n        file=ENV_FILE,\n        nested_separator=ENV_NESTED_SEP,\n    )\n\n    @property\n    def bootstrap_servers(self) -&gt; str:\n        \"\"\"The bootstrap servers for Kafka\n\n        If we are running in Docker, return the broker name and port.\n        Otherwise, return the localhost and port.\n\n        Returns:\n            str: The bootstrap servers for Kafka\n        \"\"\"\n        if _running_in_docker():\n            return f\"{self.broker_name}:{str(10_000 + self.broker_port)}\"\n        else:\n            return f\"localhost:{str(self.broker_port)}\"\n</code></pre>"},{"location":"flask.utils.settings/#src.flask_api.app.utils.settings.KafkaConfig.bootstrap_servers","title":"<code>bootstrap_servers: str</code>  <code>property</code>","text":"<p>The bootstrap servers for Kafka</p> <p>If we are running in Docker, return the broker name and port. Otherwise, return the localhost and port.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The bootstrap servers for Kafka</p>"},{"location":"flask.utils.settings/#src.flask_api.app.utils.settings.FXConfig","title":"<code>FXConfig</code>","text":"<p>               Bases: <code>BaseConfig</code></p> <p>FX Configuration</p> <p>Configuration for the fraud detection application.</p> <p>Attributes:</p> Name Type Description <code>bucket_fraud</code> <code>str</code> <p>The name of the bucket for fraudulent files</p> <code>bucket_valid</code> <code>str</code> <p>The name of the bucket for valid files</p> Source code in <code>src/flask_api/app/utils/settings.py</code> <pre><code>class FXConfig(BaseConfig):\n    \"\"\"FX Configuration\n\n    Configuration for the fraud detection application.\n\n    Attributes:\n        bucket_fraud (str): The name of the bucket for fraudulent files\n        bucket_valid (str): The name of the bucket for valid files\n    \"\"\"\n    bucket_fraud: str\n    bucket_valid: str\n\n    CONFIG_SOURCES = EnvSource(\n        allow_all=True,\n        prefix=\"FX_\",\n        file=ENV_FILE,\n        nested_separator=ENV_NESTED_SEP,\n    )\n\n    @property\n    def buckets(self) -&gt; list[str]:\n        \"\"\"The list of buckets\n\n        Returns:\n            list[str]: The list of buckets\n        \"\"\"\n        return list(vars(self).values())\n</code></pre>"},{"location":"flask.utils.settings/#src.flask_api.app.utils.settings.FXConfig.buckets","title":"<code>buckets: list[str]</code>  <code>property</code>","text":"<p>The list of buckets</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: The list of buckets</p>"},{"location":"flask.utils.settings/#src.flask_api.app.utils.settings.find","title":"<code>find(name, path)</code>","text":"<p>Find a file with the specified name in the specified path.</p> <p>This function searches for a file with the specified name in the specified path and returns the path to the file if it exists.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the file to find.</p> required <code>path</code> <code>str</code> <p>The path to search in.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The path to the file if it exists, <code>None</code> otherwise.</p> Source code in <code>src/flask_api/app/utils/settings.py</code> <pre><code>def find(name, path):\n    \"\"\"\n    Find a file with the specified name in the specified path.\n\n    This function searches for a file with the specified name in the\n    specified path and returns the path to the file if it exists.\n\n    Args:\n        name (str): The name of the file to find.\n        path (str): The path to search in.\n\n    Returns:\n        (str): The path to the file if it exists, `None` otherwise.\n    \"\"\"\n    for root, _, files in os.walk(path):\n        if name in files:\n            # print(root)\n            # print(os.path.join(root, name))\n            return os.path.join(root, name)\n</code></pre>"},{"location":"source/","title":"Source","text":""},{"location":"source/#src.source.streaming_source.log_request","title":"<code>log_request(request)</code>","text":"<p>Log requests before they are sent</p> Source code in <code>src/source/streaming_source.py</code> <pre><code>def log_request(request):\n    \"\"\"Log requests before they are sent\"\"\"\n    logger.debug(\n        f\"Request event hook: {request.method} {request.url}\"\n        + \" - Waiting for response\"\n    )\n</code></pre>"},{"location":"source/#src.source.streaming_source.log_response","title":"<code>log_response(response)</code>","text":"<p>Log responses after they are received</p> Source code in <code>src/source/streaming_source.py</code> <pre><code>def log_response(response):\n    \"\"\"Log responses after they are received\"\"\"\n    request = response.request\n    logger.debug(\n        f\"Response event hook: {request.method} {request.url}\"\n        + f\" - Status {response.status_code}\"\n    )\n</code></pre>"},{"location":"source/#src.source.streaming_source.stream_transactions","title":"<code>stream_transactions(file_path)</code>","text":"<p>Stream transactions from a CSV file</p> Source code in <code>src/source/streaming_source.py</code> <pre><code>def stream_transactions(file_path: str):\n    \"\"\"Stream transactions from a CSV file\"\"\"\n    with open(file_path, newline=\"\") as file:\n        reader = csv.DictReader(file)\n        for transaction in reader:\n            yield json.dumps(transaction)\n</code></pre>"},{"location":"source/#src.source.streaming_source.main","title":"<code>main()</code>","text":"<p>Send transactions to the server</p> Source code in <code>src/source/streaming_source.py</code> <pre><code>def main():\n    \"\"\"Send transactions to the server\"\"\"\n    with httpx.Client(event_hooks={\"response\": [log_response]}) as client:\n        for transaction in stream_transactions(SOURCE_FILE):\n            client.post(API_URL, json=transaction)\n</code></pre>"}]}